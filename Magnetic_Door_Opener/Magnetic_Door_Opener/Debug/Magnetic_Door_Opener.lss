
Magnetic_Door_Opener.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  0000030e  00000382  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000030e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00000384  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000003b4  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000000e0  00000000  00000000  000003f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000be2  00000000  00000000  000004d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000008e3  00000000  00000000  000010b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000006a2  00000000  00000000  00001999  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001c0  00000000  00000000  0000203c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000004c5  00000000  00000000  000021fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000416  00000000  00000000  000026c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000090  00000000  00000000  00002ad7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
   8:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
   c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  10:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  14:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  18:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  1c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  20:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  24:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  28:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  2c:	0c 94 32 01 	jmp	0x264	; 0x264 <__vector_11>
  30:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  34:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  38:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  3c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  40:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  44:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  48:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  4c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  50:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  54:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  58:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  5c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  60:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  64:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee e0       	ldi	r30, 0x0E	; 14
  7c:	f3 e0       	ldi	r31, 0x03	; 3
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a2 30       	cpi	r26, 0x02	; 2
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>
  8a:	0e 94 65 01 	call	0x2ca	; 0x2ca <main>
  8e:	0c 94 85 01 	jmp	0x30a	; 0x30a <_exit>

00000092 <__bad_interrupt>:
  92:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000096 <ADC_init>:
 *  in Atmega 328P
 */
void ADC_init(void)
{
	// Use connect AREF to ACCC (reference voltage select)
	ADMUX &= ~(1<<REFS1); ADMUX |= (1<<REFS0);
  96:	ec e7       	ldi	r30, 0x7C	; 124
  98:	f0 e0       	ldi	r31, 0x00	; 0
  9a:	80 81       	ld	r24, Z
  9c:	8f 77       	andi	r24, 0x7F	; 127
  9e:	80 83       	st	Z, r24
  a0:	80 81       	ld	r24, Z
  a2:	80 64       	ori	r24, 0x40	; 64
  a4:	80 83       	st	Z, r24
	
	// set prescale to 128 (125 kHz)
	ADCSRA |= (1<<ADPS1) | (1<< ADPS0); ADCSRA &= ~(1<<ADPS2);
  a6:	ea e7       	ldi	r30, 0x7A	; 122
  a8:	f0 e0       	ldi	r31, 0x00	; 0
  aa:	80 81       	ld	r24, Z
  ac:	83 60       	ori	r24, 0x03	; 3
  ae:	80 83       	st	Z, r24
  b0:	80 81       	ld	r24, Z
  b2:	8b 7f       	andi	r24, 0xFB	; 251
  b4:	80 83       	st	Z, r24
	
	// enable ADC
	//TODO: This could be power hungry since the ADC is enabled when ADC isnt being used   
	ADCSRA |= (1<<ADEN);
  b6:	80 81       	ld	r24, Z
  b8:	80 68       	ori	r24, 0x80	; 128
  ba:	80 83       	st	Z, r24
  bc:	08 95       	ret

000000be <ADC_convert>:
	
	return result;
	*/
	
	// Set the channel we wish to convert
	ADMUX |= channel;
  be:	ec e7       	ldi	r30, 0x7C	; 124
  c0:	f0 e0       	ldi	r31, 0x00	; 0
  c2:	90 81       	ld	r25, Z
  c4:	89 2b       	or	r24, r25
  c6:	80 83       	st	Z, r24
	
	// Start the conversion
	ADCSRA |= (1 << ADSC);
  c8:	ea e7       	ldi	r30, 0x7A	; 122
  ca:	f0 e0       	ldi	r31, 0x00	; 0
  cc:	80 81       	ld	r24, Z
  ce:	80 64       	ori	r24, 0x40	; 64
  d0:	80 83       	st	Z, r24
	
	// Wait for the conversion to finsih
	while ((ADCSRA & (1 << ADIF)) == 0);
  d2:	80 81       	ld	r24, Z
  d4:	84 ff       	sbrs	r24, 4
  d6:	fd cf       	rjmp	.-6      	; 0xd2 <ADC_convert+0x14>
	
	// Read out the ADC counts
	uint16_t adc_count = ADC;//(ADCL << 0) | (ADCH << 8);
  d8:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
  dc:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	
	return adc_count;
}
  e0:	08 95       	ret

000000e2 <COUNTER_16bit_init>:
 *
 */ 
void COUNTER_16bit_init(void)
{
	// Set to CTC mode
	TCCR1B |= (1<<WGM12);
  e2:	e1 e8       	ldi	r30, 0x81	; 129
  e4:	f0 e0       	ldi	r31, 0x00	; 0
  e6:	80 81       	ld	r24, Z
  e8:	88 60       	ori	r24, 0x08	; 8
  ea:	80 83       	st	Z, r24
	
	//Enable ISR when count matches OCR1 value
	TIMSK1 |= (1<<OCIE1A);
  ec:	af e6       	ldi	r26, 0x6F	; 111
  ee:	b0 e0       	ldi	r27, 0x00	; 0
  f0:	8c 91       	ld	r24, X
  f2:	82 60       	ori	r24, 0x02	; 2
  f4:	8c 93       	st	X, r24
	
	// Initial Value to count to
	OCR1A = 20;
  f6:	84 e1       	ldi	r24, 0x14	; 20
  f8:	90 e0       	ldi	r25, 0x00	; 0
  fa:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
  fe:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
	
	// Set prescaller to 1024 and start counting
	TCCR1B |= (1<<CS12) | (1<<CS10);
 102:	80 81       	ld	r24, Z
 104:	85 60       	ori	r24, 0x05	; 5
 106:	80 83       	st	Z, r24
 108:	08 95       	ret

0000010a <GPIO_init>:
 * This function initializes all pins to Vcc
 */ 
void GPIO_init(void)
{
	// Set all pins to output
	DDRD = 0xFF; DDRC = 0xFF; DDRB = 0xFF;
 10a:	8f ef       	ldi	r24, 0xFF	; 255
 10c:	8a b9       	out	0x0a, r24	; 10
 10e:	87 b9       	out	0x07, r24	; 7
 110:	84 b9       	out	0x04, r24	; 4
	
	// Set all pins to High
	PORTD = 0xFF; PORTC = 0xFF; PORTB = 0xFF;
 112:	8b b9       	out	0x0b, r24	; 11
 114:	88 b9       	out	0x08, r24	; 8
 116:	85 b9       	out	0x05, r24	; 5
 118:	08 95       	ret

0000011a <UART_init>:
{
	int i;
	for(i = 0; i < strlen(str); i++) {
		UART_transmit_char(str[i]);
	}
}
 11a:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
 11e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
 122:	88 e1       	ldi	r24, 0x18	; 24
 124:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
 128:	86 e0       	ldi	r24, 0x06	; 6
 12a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
 12e:	08 95       	ret

00000130 <uart_transmit_byte>:
 * This function transmits a byte serially via UART
 */
void uart_transmit_byte(uint8_t byte)
{
	// Wait for the UART data register empty flag
	while ((UCSR0A & 0x20) == 0) {
 130:	e0 ec       	ldi	r30, 0xC0	; 192
 132:	f0 e0       	ldi	r31, 0x00	; 0
 134:	90 81       	ld	r25, Z
 136:	95 ff       	sbrs	r25, 5
 138:	fd cf       	rjmp	.-6      	; 0x134 <uart_transmit_byte+0x4>
		;
	}
	
	// Put the byte to be sent into the data register
	UDR0 = byte;
 13a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 13e:	08 95       	ret

00000140 <UART_transmit>:

/* 
 * This function transmits an array of byte serially via UART
 */
void UART_transmit(uint8_t* byte_array, uint32_t byte_array_length)
{
 140:	8f 92       	push	r8
 142:	9f 92       	push	r9
 144:	af 92       	push	r10
 146:	bf 92       	push	r11
 148:	cf 92       	push	r12
 14a:	df 92       	push	r13
 14c:	ef 92       	push	r14
 14e:	ff 92       	push	r15
 150:	cf 93       	push	r28
 152:	df 93       	push	r29
	// Loop through each byte
	for (uint32_t i = 0; i < byte_array_length; i++) {
 154:	41 15       	cp	r20, r1
 156:	51 05       	cpc	r21, r1
 158:	61 05       	cpc	r22, r1
 15a:	71 05       	cpc	r23, r1
 15c:	a1 f0       	breq	.+40     	; 0x186 <UART_transmit+0x46>
 15e:	4a 01       	movw	r8, r20
 160:	5b 01       	movw	r10, r22
 162:	c8 2f       	mov	r28, r24
 164:	d9 2f       	mov	r29, r25
 166:	c1 2c       	mov	r12, r1
 168:	d1 2c       	mov	r13, r1
 16a:	76 01       	movw	r14, r12
		// Transmit it via the UART
		uart_transmit_byte(byte_array[i]);
 16c:	89 91       	ld	r24, Y+
 16e:	0e 94 98 00 	call	0x130	; 0x130 <uart_transmit_byte>
 * This function transmits an array of byte serially via UART
 */
void UART_transmit(uint8_t* byte_array, uint32_t byte_array_length)
{
	// Loop through each byte
	for (uint32_t i = 0; i < byte_array_length; i++) {
 172:	8f ef       	ldi	r24, 0xFF	; 255
 174:	c8 1a       	sub	r12, r24
 176:	d8 0a       	sbc	r13, r24
 178:	e8 0a       	sbc	r14, r24
 17a:	f8 0a       	sbc	r15, r24
 17c:	8c 14       	cp	r8, r12
 17e:	9d 04       	cpc	r9, r13
 180:	ae 04       	cpc	r10, r14
 182:	bf 04       	cpc	r11, r15
 184:	99 f7       	brne	.-26     	; 0x16c <UART_transmit+0x2c>
		// Transmit it via the UART
		uart_transmit_byte(byte_array[i]);
	}
}
 186:	df 91       	pop	r29
 188:	cf 91       	pop	r28
 18a:	ff 90       	pop	r15
 18c:	ef 90       	pop	r14
 18e:	df 90       	pop	r13
 190:	cf 90       	pop	r12
 192:	bf 90       	pop	r11
 194:	af 90       	pop	r10
 196:	9f 90       	pop	r9
 198:	8f 90       	pop	r8
 19a:	08 95       	ret

0000019c <int2str>:
 * e.g int a = 123
 * becomes b[3] = {"1","2","3"} 
 */

uint32_t int2str(uint16_t number, uint8_t* buffer)
{
 19c:	cf 92       	push	r12
 19e:	df 92       	push	r13
 1a0:	ef 92       	push	r14
 1a2:	ff 92       	push	r15
 1a4:	ac 01       	movw	r20, r24
	uint32_t i = 0;
	
	if(number == 0) buffer[0] = 0;
 1a6:	89 2b       	or	r24, r25
 1a8:	31 f4       	brne	.+12     	; 0x1b6 <int2str+0x1a>
 1aa:	fb 01       	movw	r30, r22
 1ac:	10 82       	st	Z, r1
 1ae:	c1 2c       	mov	r12, r1
 1b0:	d1 2c       	mov	r13, r1
 1b2:	76 01       	movw	r14, r12
 1b4:	32 c0       	rjmp	.+100    	; 0x21a <int2str+0x7e>
 1b6:	fb 01       	movw	r30, r22
 1b8:	c1 2c       	mov	r12, r1
 1ba:	d1 2c       	mov	r13, r1
 1bc:	76 01       	movw	r14, r12
	while(number != 0)
	{
		buffer[i] = (number%10) + 48;
 1be:	9a 01       	movw	r18, r20
 1c0:	ad ec       	ldi	r26, 0xCD	; 205
 1c2:	bc ec       	ldi	r27, 0xCC	; 204
 1c4:	0e 94 76 01 	call	0x2ec	; 0x2ec <__umulhisi3>
 1c8:	96 95       	lsr	r25
 1ca:	87 95       	ror	r24
 1cc:	96 95       	lsr	r25
 1ce:	87 95       	ror	r24
 1d0:	96 95       	lsr	r25
 1d2:	87 95       	ror	r24
 1d4:	9c 01       	movw	r18, r24
 1d6:	22 0f       	add	r18, r18
 1d8:	33 1f       	adc	r19, r19
 1da:	88 0f       	add	r24, r24
 1dc:	99 1f       	adc	r25, r25
 1de:	88 0f       	add	r24, r24
 1e0:	99 1f       	adc	r25, r25
 1e2:	88 0f       	add	r24, r24
 1e4:	99 1f       	adc	r25, r25
 1e6:	82 0f       	add	r24, r18
 1e8:	93 1f       	adc	r25, r19
 1ea:	9a 01       	movw	r18, r20
 1ec:	28 1b       	sub	r18, r24
 1ee:	39 0b       	sbc	r19, r25
 1f0:	c9 01       	movw	r24, r18
 1f2:	80 5d       	subi	r24, 0xD0	; 208
 1f4:	81 93       	st	Z+, r24
		number = number/10;
 1f6:	9a 01       	movw	r18, r20
 1f8:	0e 94 76 01 	call	0x2ec	; 0x2ec <__umulhisi3>
 1fc:	ac 01       	movw	r20, r24
 1fe:	56 95       	lsr	r21
 200:	47 95       	ror	r20
 202:	56 95       	lsr	r21
 204:	47 95       	ror	r20
 206:	56 95       	lsr	r21
 208:	47 95       	ror	r20
		i++;
 20a:	3f ef       	ldi	r19, 0xFF	; 255
 20c:	c3 1a       	sub	r12, r19
 20e:	d3 0a       	sbc	r13, r19
 210:	e3 0a       	sbc	r14, r19
 212:	f3 0a       	sbc	r15, r19
uint32_t int2str(uint16_t number, uint8_t* buffer)
{
	uint32_t i = 0;
	
	if(number == 0) buffer[0] = 0;
	while(number != 0)
 214:	41 15       	cp	r20, r1
 216:	51 05       	cpc	r21, r1
 218:	91 f6       	brne	.-92     	; 0x1be <int2str+0x22>
		number = number/10;
		i++;
	}
	
	return i;
 21a:	c7 01       	movw	r24, r14
 21c:	b6 01       	movw	r22, r12
 21e:	ff 90       	pop	r15
 220:	ef 90       	pop	r14
 222:	df 90       	pop	r13
 224:	cf 90       	pop	r12
 226:	08 95       	ret

00000228 <UART_transmit_number>:

/* 
 * This function transmits a number via uart
 */
void UART_transmit_number(uint16_t data)
{
 228:	cf 93       	push	r28
 22a:	df 93       	push	r29
 22c:	cd b7       	in	r28, 0x3d	; 61
 22e:	de b7       	in	r29, 0x3e	; 62
 230:	2a 97       	sbiw	r28, 0x0a	; 10
 232:	0f b6       	in	r0, 0x3f	; 63
 234:	f8 94       	cli
 236:	de bf       	out	0x3e, r29	; 62
 238:	0f be       	out	0x3f, r0	; 63
 23a:	cd bf       	out	0x3d, r28	; 61
	uint8_t byte_array[10];
 	uint32_t byte_array_length = int2str(data,byte_array);
 23c:	be 01       	movw	r22, r28
 23e:	6f 5f       	subi	r22, 0xFF	; 255
 240:	7f 4f       	sbci	r23, 0xFF	; 255
 242:	0e 94 ce 00 	call	0x19c	; 0x19c <int2str>
 246:	ab 01       	movw	r20, r22
 248:	bc 01       	movw	r22, r24
	UART_transmit(byte_array,byte_array_length);
 24a:	ce 01       	movw	r24, r28
 24c:	01 96       	adiw	r24, 0x01	; 1
 24e:	0e 94 a0 00 	call	0x140	; 0x140 <UART_transmit>
}
 252:	2a 96       	adiw	r28, 0x0a	; 10
 254:	0f b6       	in	r0, 0x3f	; 63
 256:	f8 94       	cli
 258:	de bf       	out	0x3e, r29	; 62
 25a:	0f be       	out	0x3f, r0	; 63
 25c:	cd bf       	out	0x3d, r28	; 61
 25e:	df 91       	pop	r29
 260:	cf 91       	pop	r28
 262:	08 95       	ret

00000264 <__vector_11>:
#include "Drivers/GPIO.h"
#include "Drivers/UART.h"

int c = 1;
ISR(TIMER1_COMPA_vect)
{
 264:	1f 92       	push	r1
 266:	0f 92       	push	r0
 268:	0f b6       	in	r0, 0x3f	; 63
 26a:	0f 92       	push	r0
 26c:	11 24       	eor	r1, r1
 26e:	8f 93       	push	r24
 270:	9f 93       	push	r25
	if(c == 0)
 272:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 276:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
 27a:	00 97       	sbiw	r24, 0x00	; 0
 27c:	81 f4       	brne	.+32     	; 0x29e <__vector_11+0x3a>
	{
		PORTD &= ~((1<<DDD2) | (1<<DDD3) | (1<<DDD4) | (1<<DDD5));
 27e:	8b b1       	in	r24, 0x0b	; 11
 280:	83 7c       	andi	r24, 0xC3	; 195
 282:	8b b9       	out	0x0b, r24	; 11
		OCR1A = 38*(1-0.5);
 284:	83 e1       	ldi	r24, 0x13	; 19
 286:	90 e0       	ldi	r25, 0x00	; 0
 288:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
 28c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
		c = 1;
 290:	81 e0       	ldi	r24, 0x01	; 1
 292:	90 e0       	ldi	r25, 0x00	; 0
 294:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 298:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 29c:	0f c0       	rjmp	.+30     	; 0x2bc <__vector_11+0x58>
	}
	else if(c == 1)
 29e:	01 97       	sbiw	r24, 0x01	; 1
 2a0:	69 f4       	brne	.+26     	; 0x2bc <__vector_11+0x58>
	{
		PORTD |= (1<<DDD2) | (1<<DDD3) | (1<<DDD4) | (1<<DDD5);
 2a2:	8b b1       	in	r24, 0x0b	; 11
 2a4:	8c 63       	ori	r24, 0x3C	; 60
 2a6:	8b b9       	out	0x0b, r24	; 11
		OCR1A = 38*0.5;
 2a8:	83 e1       	ldi	r24, 0x13	; 19
 2aa:	90 e0       	ldi	r25, 0x00	; 0
 2ac:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
 2b0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
		c = 0;
 2b4:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <__data_start+0x1>
 2b8:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_start>
	}
}
 2bc:	9f 91       	pop	r25
 2be:	8f 91       	pop	r24
 2c0:	0f 90       	pop	r0
 2c2:	0f be       	out	0x3f, r0	; 63
 2c4:	0f 90       	pop	r0
 2c6:	1f 90       	pop	r1
 2c8:	18 95       	reti

000002ca <main>:


int main(void)
{	
	
	ADC_init();
 2ca:	0e 94 4b 00 	call	0x96	; 0x96 <ADC_init>
	COUNTER_16bit_init();
 2ce:	0e 94 71 00 	call	0xe2	; 0xe2 <COUNTER_16bit_init>
	GPIO_init();
 2d2:	0e 94 85 00 	call	0x10a	; 0x10a <GPIO_init>
	UART_init(MYUBRR);
 2d6:	83 e3       	ldi	r24, 0x33	; 51
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	0e 94 8d 00 	call	0x11a	; 0x11a <UART_init>
	sei(); // enable global interupt 
 2de:	78 94       	sei
	
	uint16_t adc =  ADC_convert(_PC0);
 2e0:	80 e0       	ldi	r24, 0x00	; 0
 2e2:	0e 94 5f 00 	call	0xbe	; 0xbe <ADC_convert>
	UART_transmit_number(adc);
 2e6:	0e 94 14 01 	call	0x228	; 0x228 <UART_transmit_number>
 2ea:	ff cf       	rjmp	.-2      	; 0x2ea <main+0x20>

000002ec <__umulhisi3>:
 2ec:	a2 9f       	mul	r26, r18
 2ee:	b0 01       	movw	r22, r0
 2f0:	b3 9f       	mul	r27, r19
 2f2:	c0 01       	movw	r24, r0
 2f4:	a3 9f       	mul	r26, r19
 2f6:	70 0d       	add	r23, r0
 2f8:	81 1d       	adc	r24, r1
 2fa:	11 24       	eor	r1, r1
 2fc:	91 1d       	adc	r25, r1
 2fe:	b2 9f       	mul	r27, r18
 300:	70 0d       	add	r23, r0
 302:	81 1d       	adc	r24, r1
 304:	11 24       	eor	r1, r1
 306:	91 1d       	adc	r25, r1
 308:	08 95       	ret

0000030a <_exit>:
 30a:	f8 94       	cli

0000030c <__stop_program>:
 30c:	ff cf       	rjmp	.-2      	; 0x30c <__stop_program>
